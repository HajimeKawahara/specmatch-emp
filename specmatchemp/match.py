"""
@filename match.py

Defines the Match class
"""
import pandas as pd
import numpy as np
import lmfit
from scipy.interpolate import UnivariateSpline
from scipy import signal

import specmatchemp.kernels

class Match:
    def __init__(self, wav, s_targ, s_ref):
        """
        The Match class used for matching two spectra

        Args:
            wav (np.ndarray): Common wavelength scale
            s_targ (np.ndarray): 2d array containing target spectrum and uncertainty
            s_ref (np.ndarray): 2d array containing reference spectrum and uncertainty
        """
        self.w = wav
        self.s_targ = s_targ[0]
        self.serr_targ = s_targ[1]
        self.s_ref = s_ref[0]
        self.serr_ref = s_ref[1]
        self.best_params = lmfit.Parameters()
        self.best_chisq = np.NaN

    def create_model(self, params):
        """
        Creates a tweaked model based on the parameters passed,
        based on the reference spectrum.
        Stores the tweaked model in spectra.s_mod and serr_mod.
        """
        # Create a spline
        x = []
        y = []
        for i in range(params['num_knots'].value):
            p = 'knot_{0:d}'.format(i)
            x.append(params[p+'_x'].value)
            y.append(params[p+'_y'].value)
        s = UnivariateSpline(x, y, s=0)
        spl = s(self.w)

        self.s_mod = spl*self.s_mod
        self.serr_mod = spl*self.serr_mod

        # Apply broadening kernel
        SPEED_OF_LIGHT = 2.99792e5
        dv = (self.w[1]-self.w[0])/self.w[0]*SPEED_OF_LIGHT
        n = 151 # fixed number of points in the kernel
        vsini = params['vsini'].value
        varr, kernel = specmatchemp.kernels.rot(n, dv, vsini)
        self.s_mod = signal.fftconvolve(self.s_mod, kernel, mode='same')
        self.serr_mod = signal.fftconvolve(self.serr_mod, kernel, mode='same')

    def residual(self, params):
        """
        Objective function evaluating goodness of fit given the passed parameters

        Args:
            params
        Returns:
            Reduced chi-squared value between the target spectra and the 
            model spectrum generated by the parameters
        """
        self.s_mod = self.s_ref
        self.serr_mod = self.serr_ref
        self.create_model(params)

        # Calculate residuals
        diff = self.s_targ-self.s_mod

        return diff

    def best_fit(self, params=None):
        """
        Calculates the best fit model by minimizing over the parameters:
        - spline fitting to the continuum
        - rotational broadening
        """
        ### Spline parameters
        # Create a spline with 5 knots
        if params is None:
            params = lmfit.Parameters()
        num_knots = 5
        params.add('num_knots', value=num_knots, vary=False)
        interval = int(len(self.w)/(num_knots+1))
        # Add spline positions
        for i in range(num_knots):
            p = 'knot_{0:d}'.format(i)
            params.add(p+'_x', value=self.w[interval*i], vary=False)
            params.add(p+'_y', value=self.s_targ[interval*i], min=0.5, max=1.5)

        ### Rotational broadening
        params.add('vsini', value=1.0, min=0.0, max=10.0)

        # Minimize chi-squared
        out = lmfit.minimize(self.residual, params)

        # Save best fit parameters
        self.best_params = out.params
        self.best_chisq = np.sum(np.abs(self.residual(self.best_params)))

        return self.best_chisq

    def best_residuals(self):
        """Returns the residuals between the target spectrum and best-fit spectrum
        
        Returns:
            np.ndarray
        """
        self.s_mod = self.s_ref
        self.serr_mod = self.serr_ref
        self.create_model(self.best_params)

        return (self.s_targ-self.s_mod)


class MatchLincomb(Match):
    def __init__(self, wav, s_targ, s_refs):
        """
        Match subclass to find the best match from a linear combination of 
        reference spectra.

        Args:
            wav (np.ndarray): Common wavelength scale
            s_targ (np.ndarray): 2d array containing target spectrum and uncertainty
            s_refs (np.ndarray): 3d list containing reference spectra and uncertainty
        """
        self.w = wav
        self.s_targ = s_targ[0]
        self.serr_targ = s_targ[1]
        self.s_refs = s_refs
        self.num_refs = len(s_refs)
        self.best_params = lmfit.Parameters()
        self.best_chisq = np.NaN

    def create_model(self, params):
        """
        Creates a tweaked model based on the parameters passed,
        based on the reference spectrum.
        Stores the tweaked model in spectra.s_mod and serr_mod.
        """
        # create the model from a linear combination of the reference spectra
        for i in range(self.num_refs):
            p = 'coeff_{0:d}'.format(i)
            self.s_mod += self.s_refs[i,0] * params[p].value
            self.serr_mod += self.s_refs[i,1] * params[p].value

        super().create_model(params)

    def residual(self, params):
        """
        Objective function evaluating goodness of fit given the passed parameters

        Args:
            params
        Returns:
            Reduced chi-squared value between the target spectra and the 
            model spectrum generated by the parameters
        """
        self.s_mod = np.zeros_like(self.w)
        self.serr_mod = np.zeros_like(self.w)
        self.create_model(params)

        # Calculate residuals
        diff = self.s_targ-self.s_mod
        # divide by narrow Gaussian
        sum_coeff = 0
        for i in range(self.num_refs):
            p = 'coeff_{0:d}'.format(i)
            sum_coeff += params[p].value

        SUM_WIDTH = 1e-3    
        diff /= np.exp(-(sum_coeff-1)**2/(2*SUM_WIDTH**2))

        return diff

    def best_fit(self):
        """
        Calculates the best fit model by minimizing over the parameters:
        - Coefficients of reference spectra
        - spline fitting to the continuum
        - rotational broadening
        """
        params = lmfit.Parameters()
        ### Linear combination parameters
        params.add('num_refs', value=self.num_refs, vary=False)
        for i in range(self.num_refs):
            p = 'coeff_{0:d}'.format(i)
            params.add(p, value=1/self.num_refs, min=0.0, max=1.0)

        # Call standard Match class parameters
        return super().best_fit(params)

    def best_residuals(self):
        """Returns the residuals between the target spectrum and best-fit spectrum
        
        Returns:
            np.ndarray
        """
        self.s_mod = np.zeros_like(self.w)
        self.serr_mod = np.zeros_like(self.w)
        self.create_model(self.best_params)

        return (self.s_targ-self.s_mod)

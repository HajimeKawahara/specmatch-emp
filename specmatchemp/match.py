"""
@filename match.py

Defines the Match class
"""
import pandas as pd
import numpy as np
import lmfit
from scipy.interpolate import LSQUnivariateSpline
from scipy import signal
from scipy.ndimage.filters import convolve1d

import specmatchemp.kernels
from specmatchemp.spectrum import Spectrum

class Match:
    def __init__(self, target, reference, mode='default', opt='nelder'):
        """
        The Match class used for matching two spectra

        Args:
            target (Spectrum): Target spectrum
            reference (Spectrum): Reference spectrum
            mode: default (unnormalized chi-square), normalized (normalized chi-square)
            opt: lm (Levenberg-Marquadt optimization), nelder (Nelder-Mead)
        """
        if not np.allclose(target.w, reference.w):
            print("Target and reference are on different wavelength scales.")
            raise ValueError

        self.w = np.copy(target.w)
        self.s_targ = np.copy(target.s)
        self.serr_targ = np.copy(target.serr)
        self.s_ref = np.copy(reference.s)
        self.serr_ref = np.copy(reference.serr)
        # replace nans with continuum
        self.s_targ[np.isnan(self.s_targ)] = 1
        self.serr_targ[np.isnan(self.serr_targ)] = 1
        self.s_ref[np.isnan(self.s_ref)] = 1
        self.serr_ref[np.isnan(self.serr_ref)] = 1

        self.best_params = lmfit.Parameters()
        self.best_chisq = np.NaN
        self.mode = mode
        self.opt = opt

        # add spline knots
        num_knots = 5
        interval = int(len(self.w)/(num_knots+1))
        # Add spline positions
        self.knot_x = []
        for i in range(1, num_knots+1):
            self.knot_x.append(self.w[interval*i])
        self.knot_x = np.array(self.knot_x)

    def create_model(self, params):
        """
        Creates a tweaked model based on the parameters passed,
        based on the reference spectrum.
        Stores the tweaked model in spectra.s_mod and serr_mod.
        """
        self.s_mod = np.nan_to_num(self.s_ref)
        self.serr_mod = np.nan_to_num(self.serr_ref)

        # Apply broadening kernel
        vsini = params['vsini'].value
        self.s_mod = self.broaden(vsini, self.s_mod)
        self.serr_mod = self.broaden(vsini, self.serr_mod)

        # Use linear least squares to fit a spline
        s = LSQUnivariateSpline(self.w, self.s_targ/self.s_mod, self.knot_x)
        self.spl = s(self.w)

        self.s_mod *= self.spl
        self.serr_mod *= self.spl


    def broaden(self, vsini, spec):
        """
        Applies a broadening kernel to the given spectrum (or error)

        Args:
            vsini (float): vsini to determine width of broadening
            spec (np.ndarray): spectrum to broaden
        Returns:
            broadened (np.ndarray): Broadened spectrum
        """
        SPEED_OF_LIGHT = 2.99792e5
        dv = (self.w[1]-self.w[0])/self.w[0]*SPEED_OF_LIGHT
        n = 151 # fixed number of points in the kernel
        varr, kernel = specmatchemp.kernels.rot(n, dv, vsini)
        # broadened = signal.fftconvolve(spec, kernel, mode='same')
        broadened = convolve1d(spec, kernel)

        return broadened


    def objective(self, params):
        """
        Objective function evaluating goodness of fit given the passed parameters

        Args:
            params
        Returns:
            Reduced chi-squared value between the target spectra and the 
            model spectrum generated by the parameters
        """
        self.create_model(params)

        # Calculate residuals (data - model)
        if self.mode == 'normalized':
            residuals = (self.s_targ-self.s_mod)/np.sqrt(self.serr_targ**2+self.serr_mod**2)
        else:
            residuals = (self.s_targ-self.s_mod)

        chi_square = np.sum(residuals**2)

        if self.opt == 'lm':
            return residuals
        elif self.opt == 'nelder':
            return chi_square

    def best_fit(self, params=None):
        """
        Calculates the best fit model by minimizing over the parameters:
        - spline fitting to the continuum
        - rotational broadening
        """
        if params is None:
            params = lmfit.Parameters()

        ### Rotational broadening parameters
        params.add('vsini', value=1.0, min=0.0, max=10.0)

        ### Spline parameters
        params = add_spline_positions(params, self.knot_x)

        # Perform fit
        if self.opt == 'lm':
            out = lmfit.minimize(self.objective, params)
            self.best_chisq = np.sum(self.objective(out.params)**2)
        elif self.opt == 'nelder':
            out = lmfit.minimize(self.objective, params, method='nelder')
            self.best_chisq = self.objective(out.params)

        self.best_params = out.params

        return self.best_chisq

    def best_residuals(self):
        """Returns the residuals between the target spectrum and best-fit spectrum
        
        Returns:
            np.ndarray
        """
        if self.mode == 'normalized':
            return (self.s_targ-self.s_mod)/np.sqrt(self.serr_targ**2+self.serr_mod**2)
        else:
            return (self.s_targ-self.s_mod) # data - model


class MatchLincomb(Match):
    def __init__(self, target, refs, vsini, mode='default'):
        """
        Match subclass to find the best match from a linear combination of 
        reference spectra.

        Args:
            target (Spectrum): Target spectrum
            refs (list of Spectrum): Array of reference spectra
            vsini (np.ndarray): array containing vsini broadening for each reference spectrum
        """
        for i in range(len(refs)):
            if not np.allclose(target.w, refs[i].w):
                print("Target and reference {0:d} are on different wavelength scales.".format(i))
                raise ValueError

        self.w = np.copy(target.w)
        self.s_targ = np.copy(target.s)
        self.serr_targ = np.copy(target.serr)
        self.num_refs = len(refs)
        self.s_refs = np.empty(0, 2, len(self.w))
        for i in range(len(refs)):
            self.s_refs = np.vstack((self.s_refs, [refs[i].s, refs[i].serr]))

        self.vsini = vsini

        ## Broaden reference spectra
        self.s_broad = np.empty_like(self.s_refs)
        for i in range(self.num_refs):
            self.s_broad[i,0] = self.broaden(vsini[i], self.s_refs[i,0])
            self.s_broad[i,1] = self.broaden(vsini[i], self.s_refs[i,1])

        self.best_params = lmfit.Parameters()
        self.best_chisq = np.NaN
        self.mode = mode
        self.opt = 'nelder'

        # add spline knots
        num_knots = 5
        interval = int(len(self.w)/(num_knots+1))
        # Add spline positions
        self.knot_x = []
        for i in range(1, num_knots+1):
            self.knot_x.append(self.w[interval*i])
        self.knot_x = np.array(self.knot_x)

    def create_model(self, params):
        """
        Creates a tweaked model based on the parameters passed,
        based on the reference spectrum.
        Stores the tweaked model in spectra.s_mod and serr_mod.
        """
        self.s_mod = np.zeros_like(self.w)
        self.serr_mod = np.zeros_like(self.w)

        # create the model from a linear combination of the reference spectra
        coeffs = get_lincomb_coeffs(params)
        for i in range(self.num_refs):
            self.s_mod += self.s_broad[i,0] * coeffs[i]
            self.serr_mod += self.s_broad[i,1] * coeffs[i]

        # Use linear least squares to fit a spline
        s = LSQUnivariateSpline(self.w, self.s_targ/self.s_mod, self.knot_x)
        self.spl = s(self.w)

        self.s_mod *= self.spl
        self.serr_mod *= self.spl
        

    def objective(self, params):
        """
        Objective function evaluating goodness of fit given the passed parameters

        Args:
            params
        Returns:
            Reduced chi-squared value between the target spectra and the 
            model spectrum generated by the parameters
        """
        chi_square = super().objective(params)

        # Add a Gaussian prior
        sum_coeff = np.sum(get_lincomb_coeffs(params))

        WIDTH = 1e-2
        chi_square += (sum_coeff-1)**2/(2*WIDTH**2)

        return chi_square

    def best_fit(self):
        """
        Calculates the best fit model by minimizing over the parameters:
        - Coefficients of reference spectra
        - spline fitting to the continuum
        - rotational broadening
        """
        params = lmfit.Parameters()
        ### Linear combination parameters
        params = add_lincomb_coeffs(params, self.num_refs)
        ### Spline parameters
        params = add_spline_positions(params, self.knot_x)
        ### vsini
        params = add_vsini(params, self.vsini)

        # Minimize chi-squared
        out = lmfit.minimize(self.objective, params, method='nelder')

        # Save best fit parameters
        self.best_params = out.params
        self.best_chisq = self.objective(self.best_params)

        return self.best_chisq


def add_spline_positions(params, knotx):
    """Adds spline positions to the parameter list.

    Args:
        params (lmfit.Parameters): parameters
        knotx (np.array): Array of knot positions
    Returns:
        params (lmfit.Parameters)
    """
    params.add('num_knots', value=len(knotx), vary=False)

    for i in range(len(knotx)):
        p = 'knotx_{0:d}'.format(i)
        params.add(p, value=knotx[i], vary=False)

    return params

def get_spline_positions(params):
    """Gets the spline positions from an lmfit parameters object.

    Args:
        params (lmfit.Parameters): parameters
    Returns:
        knotx (np.ndarray)
    """
    num_knots = params['num_knots'].value

    knotx = []
    for i in range(num_knots):
        p = 'knotx_{0:d}'.format(i)
        knotx.append(params[p].value)

    return np.array(knotx)

def add_vsini(params, vsini):
    """Adds vsini to an lmfit parameter list.
    
    Args:
        params (lmfit.Parameters): parameters
        vsini (np.ndarray): vsini values for each reference spectrum
    Returns:
        params (lmfit.Parameters)
    """
    if 'num_refs' not in params.valuesdict():
        params.add('num_refs', value=len(vsini), vary=False)

    for i in range(len(vsini)):
        p = 'vsini_{0:d}'.format(i)
        params.add(p, value=vsini[i], vary=False)

    return params

def get_vsini(params):
    """Gets vsini list from a parameters object.

    Args:
        params (lmfit.Parameters): parameters
    Returns:
        vsini (np.ndarray)
    """
    num_refs = params['num_refs'].value

    vsini = []
    for i in range(num_refs):
        p = 'vsini_{0:d}'.format(i)
        vsini.append(params[p].value)

    return np.array(vsini)



def add_lincomb_coeffs(params, num_refs):
    """Adds lincomb coefficients to an lmfit parameter list.

    Args:
        params (lmfit.Parameters): parameters
        num_refs (int): Number of reference spectra
    Returns:
        params (lmfit.Parameters)
    """
    if 'num_refs' not in params.valuesdict():
        params.add('num_refs', value=num_refs, vary=False)

    for i in range(num_refs):
        p = 'coeff_{0:d}'.format(i)
        params.add(p, value=1/num_refs, min=0.0, max=1.0)

    return params


def get_lincomb_coeffs(params):
    """Gets the lincomb coefficients form an lmfit parameter list.

    Args:
        params (lmfit.Paremters): parameters
    Returns:
        coeffs (np.ndarray)
    """
    num_refs = params['num_refs'].value

    coeffs = []
    for i in range(num_refs):
        p = 'coeff_{0:d}'.format(i)
        coeffs.append(params[p].value)

    return np.array(coeffs)